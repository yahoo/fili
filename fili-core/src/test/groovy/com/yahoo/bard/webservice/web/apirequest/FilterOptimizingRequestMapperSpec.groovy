package com.yahoo.bard.webservice.web.apirequest

import com.yahoo.bard.webservice.data.FilterOptimizable
import com.yahoo.bard.webservice.data.config.ResourceDictionaries
import com.yahoo.bard.webservice.data.dimension.Dimension
import com.yahoo.bard.webservice.web.ApiFilter
import com.yahoo.bard.webservice.web.ChainingRequestMapper
import com.yahoo.bard.webservice.web.DataApiRequestMapperUtils
import com.yahoo.bard.webservice.web.FilterOptimizingRequestMapper
import com.yahoo.bard.webservice.web.RequestMapper
import com.yahoo.bard.webservice.web.filters.ApiFilters

import spock.lang.Specification

import javax.ws.rs.container.ContainerRequestContext

class FilterOptimizingRequestMapperSpec extends Specification {

    private static interface FilterOptimizingDimension extends Dimension, FilterOptimizable {}

    ChainingRequestMapper<DataApiRequest> mapper

    def setup() {
        ResourceDictionaries dictionaries = new ResourceDictionaries()
        mapper = new FilterOptimizingRequestMapper(dictionaries, DataApiRequestMapperUtils.identityMapper(dictionaries))
    }

    def "null and empty filters are output as empty filters"() {
        setup:
        DataApiRequest request = Mock(DataApiRequest) {getApiFilters() >> filters}

        when:
        DataApiRequest result = mapper.internalApply(request, Mock(ContainerRequestContext))

        then:
        0 * request.withFilters()
        result == request

        where:
        filters << [null, new ApiFilters()]
    }

    def "non-optimizable dimensions are ignored"() {
        setup:
        Dimension dim1 = Mock()
        Dimension dim2 = Mock(FilterOptimizingDimension)
        Set<ApiFilter> dim1Filters = [Mock(ApiFilter) {getDimension() >> dim1}, Mock(ApiFilter) {getDimension() >> dim1}]
        Set<ApiFilter> dim2Filters_1 = [Mock(ApiFilter) {getDimension() >> dim2}]
        Set<ApiFilter> dim2Filters_2 = [Mock(ApiFilter) {getDimension() >> dim2}]

        DataApiRequest request = Mock(DataApiRequest) {
            getApiFilters() >> new ApiFilters([
                    (dim1): dim1Filters,
                    (dim2): dim2Filters_1,
            ] as Map<Dimension, Set<ApiFilter>>)
        }

        when:
        mapper.internalApply(request, Mock(ContainerRequestContext))

        then: "both dimensions optimize their filters"
        0 * dim1._
        1 * dim2.optimizeFilters(dim2Filters_1) >> dim2Filters_2

        and: "filters are unchanged since optimize is a noop for both dimensions"
        1 * request.withFilters({
                it == [
                        (dim1): dim1Filters,
                        (dim2): dim2Filters_2
                ]
        })
    }

    def "If a filter is generated by optimization it is added to the filter map"() {
        setup:
        Dimension dim = Mock(FilterOptimizingDimension)
        ApiFilter inFilter = Mock(ApiFilter) {getDimension() >> dim}
        ApiFilter addedFilter = Mock(ApiFilter) {getDimension() >> dim}
        Set<ApiFilter> expectedFilters = [inFilter, addedFilter] as Set

        DataApiRequest request = Mock(DataApiRequest) {getApiFilters() >> new ApiFilters([
                (dim): [inFilter]
        ] as Map<Dimension, Set<ApiFilter>>)}

        when:
        mapper.internalApply(request, Mock(ContainerRequestContext))

        then:
        1 * dim.optimizeFilters([inFilter]) >> expectedFilters
        1 * request.withFilters(new ApiFilters([(dim): expectedFilters]))
    }

    def "Optimizations that remove all filters remove the dimension from the filter set as well"() {
        setup:
        Dimension dim = Mock(FilterOptimizingDimension)
        Set<ApiFilter> filters = [Mock(ApiFilter)]
        DataApiRequest request = Mock(DataApiRequest) { getApiFilters() >> new ApiFilters([(dim): filters] as Map<Dimension, Set<ApiFilter>>)}

        when:
        mapper.internalApply(request, Mock(ContainerRequestContext))

        then:
        1 * dim.optimizeFilters(filters) >> []
        1 * request.withFilters({ApiFilters it -> it.isEmpty()})
    }


    def "If an optimization adds a new dimension to the filter set the new dimension is properly split out into the map"() {
        setup:
        Dimension dim1 = Mock(FilterOptimizingDimension)
        Dimension dim2 = Mock(FilterOptimizingDimension)
        ApiFilter dim1OutputFilter = Mock(ApiFilter) {getDimension() >> dim1}
        ApiFilter dim2OutputFilter = Mock(ApiFilter) {getDimension() >> dim2}

        DataApiRequest request = Mock(DataApiRequest) {getApiFilters() >> new ApiFilters([
                (dim1): [Mock(ApiFilter)] as Set<ApiFilter>
        ] as Map<Dimension, Set<ApiFilter>>)}

        when:
        mapper.internalApply(request, Mock(ContainerRequestContext))

        then:
        1 * dim1.optimizeFilters(_) >> [dim1OutputFilter, dim2OutputFilter]
        0 * dim2.optimizeFilters(_)
        1 * request.withFilters({
            ApiFilters it ->
                it.size() == 2 &&
                        it.containsKey(dim1) &&
                        it.containsKey(dim2) &&
                        it.get(dim1) == [dim1OutputFilter] as Set<ApiFilter> &&
                        it.get(dim2) == [dim2OutputFilter] as Set<ApiFilter>
        })
    }

    def "If an optimization totally transforms a filter into a filter on a totally different dimension, the original dimension is not in the result"() {
        setup:
        Dimension dim1 = Mock(FilterOptimizingDimension)
        Dimension dim2 = Mock(FilterOptimizingDimension)
        ApiFilter dim2OutputFilter = Mock(ApiFilter) {getDimension() >> dim2}

        DataApiRequest request = Mock(DataApiRequest) {
            getApiFilters() >> new ApiFilters([
                    (dim1): [Mock(ApiFilter)]
            ] as Map<Dimension, Set<ApiFilter>>)
        }

        when:
        mapper.internalApply(request, Mock(ContainerRequestContext))

        then:
        1 * dim1.optimizeFilters(_) >> [dim2OutputFilter]
        0 * dim2.optimizeFilters(_)
        1 * request.withFilters(new ApiFilters([
                  (dim2) : [dim2OutputFilter] as Set
            ] as Map<Dimension, Set<ApiFilter>>)
        )
    }

    def "Filters that get optimized to a different dimension that is also getting filtered on do not get wiped out"() {
        setup:
        Dimension optimizable = Mock(FilterOptimizingDimension)
        Dimension regular = Mock(Dimension)

        ApiFilter baseOptimizableFilter = Mock() {getDimension() >> optimizable}
        ApiFilter baseRegular = Mock() {getDimension() >> regular}
        ApiFilter optimizedRegular = Mock() {getDimension() >> regular}

        ApiFilters expectedApiFilters

        DataApiRequest request = Mock(DataApiRequest) {getApiFilters() >> {expectedApiFilters} }

        when: "first check order of regular then optimizable"
        expectedApiFilters = new ApiFilters()
        expectedApiFilters.put(regular, [baseRegular] as Set<ApiFilter>)
        expectedApiFilters.put(optimizable, [baseOptimizableFilter] as Set<ApiFilter>)
        mapper.internalApply(request, Mock(ContainerRequestContext))

        then:
        1 * optimizable.optimizeFilters(_) >> {[optimizedRegular] as Set}
        1 * request.withFilters({
            ApiFilters it ->
                it == [
                        (regular): [baseRegular, optimizedRegular] as Set<ApiFilter>
                ] as ApiFilters
        })

        when: "next check or of optimizable then regular"
        expectedApiFilters = new ApiFilters()
        expectedApiFilters.put(optimizable, [baseOptimizableFilter] as Set<ApiFilter>)
        expectedApiFilters.put(regular, [baseRegular] as Set<ApiFilter>)
        mapper.internalApply(request, Mock(ContainerRequestContext))

        then:
        1 * optimizable.optimizeFilters(_) >> {[optimizedRegular] as Set}
        1 * request.withFilters({
            new ApiFilters([
                    (optimizable): [baseOptimizableFilter],
                    (regular): [baseRegular],
            ] as LinkedHashMap<Dimension, Set<ApiFilter>>)
        })
    }
}
