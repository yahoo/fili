// Copyright 2016 Yahoo Inc.
// Licensed under the terms of the Apache license. Please see LICENSE file distributed with this work for terms.
package com.yahoo.bard.webservice.async.workflows;

import static com.yahoo.bard.webservice.async.jobs.jobrows.DefaultJobField.DATE_UPDATED;
import static com.yahoo.bard.webservice.async.jobs.jobrows.DefaultJobField.STATUS;
import static com.yahoo.bard.webservice.async.jobs.jobrows.DefaultJobStatus.FAILURE;
import static com.yahoo.bard.webservice.async.jobs.jobrows.DefaultJobStatus.SUCCESS;

import com.yahoo.bard.webservice.async.AsyncUtils;
import com.yahoo.bard.webservice.async.jobs.stores.ApiJobStore;
import com.yahoo.bard.webservice.async.jobs.jobrows.JobField;
import com.yahoo.bard.webservice.async.jobs.jobrows.JobRow;
import com.yahoo.bard.webservice.async.preresponses.stores.PreResponseStore;
import com.yahoo.bard.webservice.util.Either;
import com.yahoo.bard.webservice.web.ErrorMessageFormat;
import com.yahoo.bard.webservice.web.PreResponse;
import com.yahoo.bard.webservice.web.responseprocessors.ResponseContextKeys;

import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import rx.Observable;
import rx.observables.ConnectableObservable;

import java.time.Clock;
import java.util.function.Function;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Builds an Asynchronous process that only saves the results of a query if the query is asynchronous.
 */
@Singleton
public class DefaultAsynchronousWorkflowsBuilder implements AsynchronousWorkflowsBuilder {
    private static final Logger LOG = LoggerFactory.getLogger(DefaultAsynchronousWorkflowsBuilder.class);

    private final ApiJobStore apiJobStore;
    private final PreResponseStore preResponseStore;
    private final Clock timestampGenerator;

    /**
     * A factory for constructing the asynchronous response building workflow.
     *
     * @param apiJobStore  A service for storing and requesting job metadata
     * @param preResponseStore  A service for storing and requesting query results
     * @param timestampGenerator  The clock to use to generate timestamps
     */
    @Inject
    public DefaultAsynchronousWorkflowsBuilder(
            ApiJobStore apiJobStore,
            PreResponseStore preResponseStore,
            Clock timestampGenerator
    ) {
        this.apiJobStore = apiJobStore;
        this.preResponseStore = preResponseStore;
        this.timestampGenerator = timestampGenerator;
    }

    @Override
    public AsynchronousWorkflows buildAsynchronousWorkflows(
            Observable<PreResponse> preResponseEmitter,
            Observable<Either<PreResponse, JobRow>> payloadEmitter,
            JobRow jobMetadata,
            Function<JobRow, String> jobMetadataSerializer
    ) {

        // This will emit the job metadata iff the query is asynchronous, and be empty iff the query is sychronous.
        // It is replayable because some the asynchronous workflows use this observable as a gate via the delay
        // operator.
        ConnectableObservable<JobRow> asynchronousPayload = payloadEmitter
                .filter(Either::isRight)
                .map(Either::getRight)
                .replay(1);

        asynchronousPayload.connect();

        // This will emit the PreResponse iff the query is synchronous, and be empty iff the query is asynchronous. It
        // is the duel of asynchronousPayload.
        Observable<PreResponse> synchronousPayload = payloadEmitter.filter(Either::isLeft).map(Either::getLeft);

        // This observable ensures that any error messages that are generated by query processing are properly stored
        // in the result store, by converting any errors into special PreResponses.
        Observable<PreResponse> errorHandlingPreResponseEmitter = preResponseEmitter
                .onErrorReturn(AsyncUtils::buildErrorPreResponse);

        // This attempts to stores the JobRow (the asynchronous payload) in the ApiJobStore, and emits a notification
        // when that attempt is completed. It is replayable, because the workflow that updates the status of the job
        // with "success" uses this notification as a gate.
        ConnectableObservable<JobRow> jobRowStoredNotification = buildJobRowStoredNotification(
                asynchronousPayload,
                jobMetadata
        )
                .replay(1);
        jobRowStoredNotification.connect();

        // This attempts to store the PreResponse in the PreResponse store, but only if the query is asynchronous
        // (i.e. asynchronousPayload is non-empty). It is replayable because it serves as a gate for the workflow that
        // updates the job's status when the query is completed.
        ConnectableObservable<String> preResponseStoredNotification = buildStorePreResponseChain(
                errorHandlingPreResponseEmitter,
                asynchronousPayload,
                jobMetadata
        )
                .replay(1);
        preResponseStoredNotification.connect();

        // This updates the job's status with either success or failure, depending on whether the PreResponse emitted by
        // the preResponseEmitter contains results or an error. It will not update the status until the PreResponse has
        // been stored, and the original version of the JobRow has been stored. We need to wait until the original
        // JobRow has been stored because otherwise we have a race condition where the version of the JobRow with
        // a success/failure status could be written to the store first, and then immediately overwritten by the
        // original JobRow, leaving the JobRow in a state of "pending" for its lifetime.
        Observable<JobRow> jobRowUpdatedNotification = buildUpdateRowChain(
                jobRowStoredNotification,
                preResponseStoredNotification,
                errorHandlingPreResponseEmitter,
                jobMetadata
        );

        return new AsynchronousWorkflows(
                synchronousPayload,
                asynchronousPayload.map(jobMetadataSerializer::apply),
                preResponseStoredNotification,
                jobRowUpdatedNotification
        );
    }

    /**
     * Constructs the observable chain that stores the JobRow in the ApiJobStore, and then emits the JobRow
     * upon successful storage of the ApiJobStore.
     * <p>
     * If an error occurs while attempting to store the JobRow, the error is logged and the JobRow is still emitted.
     *
     * @param asynchronousPayload  The Observable that emits a JobRow iff the query is asynchronous
     * @param jobRow  The jobRow to store
     *
     * @return An Observable that will emit the metadata about the current query once an attempt to store it in the
     * ApiJobStore has been completed
     */
    private Observable<JobRow> buildJobRowStoredNotification(Observable<JobRow> asynchronousPayload, JobRow jobRow) {
        return asynchronousPayload
                .flatMap(apiJobStore::save)
                .onErrorReturn(error -> {
                    LOG.warn(ErrorMessageFormat.FAILED_TO_SAVE_JOB_ROW.format(jobRow), error);
                    return jobRow;
                });
    }


    /**
     * Constructs the observable chains that handle processing the results of an asynchronous query.
     * <p>
     *  When processing an asynchronous request, we must do the following:
     *  <ol>
     *      <li> Store the job metadata in the ApiJobStore.
     *      <li> Store the results of the response in the PreResponseStore.
     *      <li> Notify all long pollers when the response is available.
     *  </ol>
     *
     * @param preResponseEmitter  The observable that will eventually emit the PreResponse
     * @param asynchronousPayload  The observable that will eventually emit the JobRow
     * @param jobRow  A producer that generates an instance of the JobRow to save when needed
     *
     * @return A stream of notifications that the PreResponse has been successfully stored
     */
    private Observable<String> buildStorePreResponseChain(
            Observable<PreResponse> preResponseEmitter,
            Observable<JobRow> asynchronousPayload,
            JobRow jobRow
    ) {
        // We don't want to store the result in the PreResponseStore unless the query is asynchronous. The query is
        // asynchronous iff the asynchronousPayload emits at least one item.
        return preResponseEmitter
                .delay(ignored -> asynchronousPayload)
                .flatMap(preResponse -> preResponseStore.save(jobRow.getId(), preResponse));
    }


    /**
     * Builds the notification channel that updates the JobRow with the success or error status upon completion.
     * <p>
     * The JobRow's status is updated once both the initial JobRow has been stored (to protect against a potential
     * race condition, where this update gets overwritten by the original "pending" ticket), and the PreResponse has
     * been successfully stored.
     *
     * @param jobRowStoredNotification  The stream of notifications indicating that the original JobRow has been
     * stored
     * @param preResponseStoredNotification  The stream of notifications indicating that the PreResponse has been
     * stored
     * @param preResponseEmitter  The stream that will eventually release the
     * @param jobMetadata  The metadata about the current query
     *
     * @return A stream of notifications indicating that the query status has been successfully updated
     */
    private Observable<JobRow> buildUpdateRowChain(
            Observable<JobRow> jobRowStoredNotification,
            Observable<String> preResponseStoredNotification,
            Observable<PreResponse> preResponseEmitter,
            JobRow jobMetadata
    ) {
        // The job status should not be updated until both the PreResponse has been stored, and the storage of the
        // original Job ticket has been attempted.
        return preResponseEmitter
                .delay(ignored -> preResponseStoredNotification)
                .delay(ignored -> jobRowStoredNotification)
                .map(PreResponse::getResponseContext)
                .map(responseContext -> responseContext.containsKey(ResponseContextKeys.ERROR_MESSAGE.getName()))
                .map(isError -> isError ?
                        updateField(jobMetadata, STATUS, FAILURE.getName()) :
                        updateField(jobMetadata, STATUS, SUCCESS.getName())
                )
                .flatMap(apiJobStore::save);
    }

    /**
     * Returns a copy of the specified JobRow with the specified field set to the specified value.
     * The returned JobRow also has the DATE_UPDATED field set to the start of the current day.
     *
     * @param row  The row to use as a prototype for the new row
     * @param field  The field to update
     * @param value  The value to assign to the field
     *
     * @return A JobRow that is identical to the specified row, except with the specified field set to the specified
     * value, and the DATE_UPDATED field set to the current instant according to timestampGenerator
     */
    private JobRow updateField(JobRow row, JobField field, String value) {
        return row
                .withFieldValue(field, value)
                .withFieldValue(
                        DATE_UPDATED,
                        new DateTime(timestampGenerator.instant().toEpochMilli()).toDateTimeISO().toString()
                );
    }
}
